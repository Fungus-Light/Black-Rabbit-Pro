"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateDialog = exports.DialogManager = void 0;
const csharp_1 = require("csharp");
const SayDialog_1 = require("Dialog/SayDialog");
const Common_1 = require("Utils/Common");
/**
 * Manage A Dialog FLow
 */
class DialogManager {
    constructor() {
        this.FlowList = new Array();
    }
    /**
     * Say Somthing
     * @param text Content
     * @param dialogName The Name Of A SayDialog Obj
     * @param character Specify A Character
     * @param clearPrevious
     * @param waitForInput
     * @param fadeWhenDone
     * @param stopVoiceover
     * @param waitForVO
     * @param clip
     */
    Say(text, dialogName, character, clearPrevious, waitForInput, fadeWhenDone, stopVoiceover, waitForVO, clip) {
        let Dialog = null;
        if (dialogName != undefined && dialogName != "") {
            Dialog = SayDialog_1.$SayDialog(dialogName);
            if (Dialog == null) {
                Common_1.Debug.LogError("SayDialog " + dialogName + "Can Not Be Found!!!");
                return;
            }
        }
        if (Dialog == undefined) {
            Dialog = SayDialog_1.$SayDialog();
        }
        if (character != undefined) {
            Dialog.SetCharacter(character);
        }
        if (clearPrevious == undefined) {
            clearPrevious = true;
        }
        if (waitForInput == undefined) {
            waitForInput = true;
        }
        if (fadeWhenDone == undefined) {
            fadeWhenDone = true;
        }
        if (stopVoiceover == undefined) {
            stopVoiceover = true;
        }
        if (waitForVO == undefined) {
            waitForVO = true;
        }
        if (clip == undefined) {
            clip = null;
        }
        //Debug.LogWarning(text + " " + fadeWhenDone + " " + clearPrevious + " " + waitForInput + " " + waitForVO + " " + stopVoiceover)
        this.FlowList.push(() => {
            Dialog.gameObject.SetActive(true);
            Dialog.Say(text, clearPrevious, waitForInput, fadeWhenDone, stopVoiceover, waitForVO, clip, () => {
                this.Gonext();
            });
        });
    }
    WaitForFrames(count) {
        this.FlowList.push(() => {
            csharp_1.CommonJsCall.WaitForFrames(Math.floor(count), () => {
                this.Gonext();
            });
        });
    }
    WaitForSeconds(count) {
        this.FlowList.push(() => {
            csharp_1.CommonJsCall.WaitForSeconds(count, () => {
                this.Gonext();
            });
        });
    }
    WaitForSecondsUnscaled(count) {
        this.FlowList.push(() => {
            csharp_1.CommonJsCall.WaitForSecondsRealtime(count, () => {
                this.Gonext();
            });
        });
    }
    /**
     * Set The CallBack When Flow is End
     * @param cb
     */
    SetCallBack(cb) {
        this.CB = cb;
        Common_1.Debug.LogWarning("Call Back Setted");
    }
    Gonext() {
        if (this.FlowList.length > 0) {
            let step = this.FlowList.shift();
            step();
        }
        else {
            Common_1.Debug.LogWarning("Nothing To Talk.");
            if (this.CB == null) {
                Common_1.Debug.LogWarning("CB is Nothing");
            }
            else {
                this.CB();
            }
        }
    }
    /**
     * Start A FLow
     */
    Start() {
        this.Gonext();
    }
}
exports.DialogManager = DialogManager;
function CreateDialog() {
    return new DialogManager;
}
exports.CreateDialog = CreateDialog;
//# sourceMappingURL=DialogManager.js.map